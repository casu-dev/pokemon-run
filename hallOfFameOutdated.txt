  def reset_moves
    this_level = self.level
    # Find all level-up moves that self could have learned
    moveset = self.getMoveList
    knowable_moves = []
    moveset.each { |m| knowable_moves.push(m[1]) if m[0] <= this_level }
    # Remove duplicates (retaining the latest copy of each move)
    knowable_moves |= []
    knowable_moves = knowable_moves.shuffle
    non_attack_moves = []  
    blacklist_moves = []
    knowable_moves.each do |m|
        if GameData::Move.get(m).base_damage == 0
          non_attack_moves.push(m)
        elsif GameData::Move.get(m).base_damage >= 140
          blacklist_moves.push(m)
        end
      end
    knowable_moves -= blacklist_moves
    knowable_moves = knowable_moves.sort_by do |m|
      # Here we can calucalte the move quality. Higher is better
      move_data = GameData::Move.get(m)
      acc = move_data.accuracy
      acc = 100 if move_data.accuracy == 0
      move_data.base_damage * acc
    end
    # Add all moves    
    @moves.clear
    kml = knowable_moves.length
    first_move_index = kml - MAX_MOVES
    first_move_index = 0 if first_move_index < 0
    if first_move_index > 0
      chosenMoves = [knowable_moves[kml-3], knowable_moves[kml-2], knowable_moves[kml-1]]
      non_attack_moves -= chosenMoves
      if non_attack_moves.length > 0
        random_weak_move = non_attack_moves.sample
        knowable_moves[first_move_index] = random_weak_move
      else
        random_weak_move = knowable_moves[0..first_move_index].sample
        knowable_moves[first_move_index] = random_weak_move
      end
    end
    #Run array backwards
    lastLoopIndex = kml - first_move_index
    for i in 1..lastLoopIndex
      @moves.push(Pokemon::Move.new(knowable_moves[kml-i]))
    end
  end


old