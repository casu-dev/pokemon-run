def reset_moves
    this_level = self.level
    # Find all level-up moves that self could have learned
    moveset = self.getMoveList
    knowable_moves = []
    moveset.each { |m| knowable_moves.push(m[1]) if m[0] <= this_level }
    # Remove duplicates (retaining the latest copy of each move)
    knowable_moves |= []
    knowable_moves = knowable_moves.shuffle
    non_attack_moves = []  
    blacklist_moves = []
    knowable_moves.each do |m|
        if GameData::Move.get(m).base_damage == 0
          non_attack_moves.push(m)
        elsif GameData::Move.get(m).base_damage >= 140
          blacklist_moves.push(m)
        end
      end
    knowable_moves -= blacklist_moves
    knowable_moves = knowable_moves.sort_by do |m|
      # Here we can calucalte the move quality. Higher is better
      move_data = GameData::Move.get(m)
      attack = self.baseStats[:ATTACK]
      attack = self.baseStats[:SPECIAL_ATTACK] if (move_data.category == 1)
      stab = 1
      stab = 1.5 if (self.type1 == move_data.type || self.type2 == move_data.type)
      acc = move_data.accuracy
      acc = 100 if move_data.accuracy == 0      
      move_data.base_damage * acc * stab * attack
    end
    # Delete Type duplicates for attacking moves   
    @moves.clear
    kml = knowable_moves.length
    blacklist_moves = []
    attack_moves = knowable_moves.clone
    attack_moves -= non_attack_moves
    (1...attack_moves.length).each do |i|
      myType = GameData::Move.get(attack_moves[i]).type
      (0...i).each do |j|
        if ((!(blacklist_moves.include? attack_moves[j]))&&(myType == GameData::Move.get(attack_moves[j]).type)&& ((kml-blacklist_moves.length-1) >= 4))
          blacklist_moves.push(attack_moves[j])
        end
      end
    end
    knowable_moves -= blacklist_moves
    attack_moves = knowable_moves.clone
    attack_moves -= non_attack_moves
    non_attack_moves = non_attack_moves.shuffle
    non_attack_moves += attack_moves
    knowable_moves = non_attack_moves
    # Add all moves 
    kml = knowable_moves.length
    first_move_index = kml - MAX_MOVES
    first_move_index = 0 if first_move_index < 0
    if first_move_index > 0
      chosenMoves = [knowable_moves[kml-3], knowable_moves[kml-2], knowable_moves[kml-1]]
      non_attack_moves -= chosenMoves
      if non_attack_moves.length > 0
        random_weak_move = non_attack_moves.sample
        knowable_moves[first_move_index] = random_weak_move
      else
        random_weak_move = knowable_moves[0..first_move_index].sample
        knowable_moves[first_move_index] = random_weak_move
      end
    end
    #Run array backwards
    lastLoopIndex = kml - first_move_index
    for i in 1..lastLoopIndex
      @moves.push(Pokemon::Move.new(knowable_moves[kml-i]))
    end
  end